{"version":3,"sources":["../node_modules/prismjs/components/prism-js-templates.js"],"names":["Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","RegExp","lookbehind","greedy","template-punctuation","alias","embedded-code","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","interpolation","placeholderCounter","placeholderMap","embeddedTokens","map","token","placeholder","interpolationExpression","content","indexOf","join","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","filter","Boolean","supportedLanguages","js","typescript","ts","jsx","tsx","stringContent","value","add","findTemplateStrings","l","type","embedded"],"mappings":"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","file":"static/js/205.806461f0.chunk.js","sourcesContent":["(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\n\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n  /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */\n\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n\n  Prism.languages.javascript['template-string'] = [// styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:md|markdown)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source), // vanilla template string\n  templateString].filter(Boolean);\n  /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */\n\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n  /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */\n\n\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n  /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */\n\n\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n    /** @type {Array} */\n\n    var tokens = Prism.tokenize(expression, tempGrammar);\n\n    if (tokens.length === 3) {\n      /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n  /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */\n\n\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n    // because they might be escaped, we need a lookbehind, so we use Prism\n\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    }); // replace all interpolations with a placeholder which is not in the code already\n\n\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n\n    var placeholderMap = {};\n\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {}\n\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join(''); // 2. Tokenize the embedded code\n\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n    /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */\n\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n\n        var token = tokens[i];\n\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token :\n          /** @type {string} */\n          token.content;\n          var index = s.indexOf(placeholder);\n\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n\n            if (before) {\n              replacement.push(before);\n            }\n\n            replacement.push(middle);\n\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n  /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */\n\n\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n    /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */\n\n\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          continue;\n        }\n\n        var content = token.content;\n\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n\n          continue;\n        }\n\n        if (token.type === 'template-string') {\n          /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */\n          var embedded = content[1];\n\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n\n    findTemplateStrings(env.tokens);\n  });\n  /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */\n\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(Prism);"],"sourceRoot":""}