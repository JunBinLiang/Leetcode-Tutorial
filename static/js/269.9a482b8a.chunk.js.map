{"version":3,"sources":["../node_modules/prismjs/components/prism-naniscript.js"],"names":["Prism","expressionDef","params","quoted-string","pattern","alias","command-param-id","lookbehind","command-param-value","greedy","getTextContent","token","Array","isArray","map","join","content","languages","naniscript","comment","define","inside","value","key","label","command","command-name","expression","command-params","generic-text","escaped-char","inline-command","command-param-name","start-stop-char","nani","hooks","add","env","tokens","forEach","type","input","stack","i","length","bracket","bracketsIndex","indexOf","push","pop","isBracketsBalanced"],"mappings":"8EAAA,SAAAA,GACA,IAAAC,EAAA,qBACAC,EAAA,CACAC,gBAAA,CACAC,QAAA,oBACAC,MAAA,YAEAC,mBAAA,CACAF,QAAA,WACAG,YAAA,EACAF,MAAA,YAEAG,sBAAA,EACAJ,QAAAH,EACAI,MAAA,YACK,CACLD,QAAA,aACAG,YAAA,EACAE,QAAA,EACAJ,MAAA,YACK,CACLD,QAAA,cACAC,MAAA,cAwIA,SAAAK,EAAAC,GACA,wBAAAA,EACAA,EACKC,MAAAC,QAAAF,GACLA,EAAAG,IAAAJ,GAAAK,KAAA,IAEAL,EAAAC,EAAAK,SA3IAhB,EAAAiB,UAAAC,WAAA,CAEAC,QAAA,CACAf,QAAA,gBACAG,YAAA,GAIAa,OAAA,CACAhB,QAAA,QACAC,MAAA,MACAgB,OAAA,CACAC,MAAA,CACAlB,QAAA,gCACAG,YAAA,EACAF,MAAA,YAEAkB,IAAA,CACAnB,QAAA,UACAG,YAAA,KAKAiB,MAAA,CACApB,QAAA,8BACAG,YAAA,EACAF,MAAA,SAEAoB,QAAA,CACArB,QAAA,8BACAG,YAAA,EACAF,MAAA,WACAgB,OAAA,CACAK,eAAA,QACAC,WAAA,CACAvB,QAAAH,EACAQ,QAAA,EACAJ,MAAA,YAEAuB,iBAAA,CACAxB,QAAA,mBACAiB,OAAAnB,KAKA2B,eAAA,CACAzB,QAAA,wBACAG,YAAA,EACAF,MAAA,cACAgB,OAAA,CAEAS,eAAA,cACAH,WAAA,CACAvB,QAAAH,EACAQ,QAAA,EACAJ,MAAA,YAEA0B,iBAAA,CACA3B,QAAA,4BACAK,QAAA,EACAJ,MAAA,WACAgB,OAAA,CACAO,iBAAA,CACAxB,QAAA,iCACAG,YAAA,EACAc,OAAAnB,GAEA8B,qBAAA,CACA5B,QAAA,iBACAG,YAAA,EACAF,MAAA,QAEA4B,kBAAA,cAMAjC,EAAAiB,UAAAiB,KAAAlC,EAAAiB,UAAA,WAQAjB,EAAAmC,MAAAC,IAAA,0BAAAC,GAEAA,EAAAC,OACAC,QAAA,SAAA5B,GACA,qBAAAA,GAAA,iBAAAA,EAAA6B,KAAA,CACA,IAAAxB,EAAAN,EAAAC,IAcA,SAAA8B,GAIA,IAHA,IACAC,EAAA,GAEAC,EAAA,EAAmBA,EAAAF,EAAAG,OAAkBD,IAAA,CACrC,IAAAE,EAAAJ,EAAAE,GACAG,EALA,OAKAC,QAAAF,GAEA,QAAAC,EACA,GAAAA,EAAA,MACAJ,EAAAM,KAAAF,EAAA,QACS,GAAAJ,EAAAO,QAAAH,EACT,SAKA,WAAAJ,EAAAE,QA7BAM,CAAAlC,KACAL,EAAA6B,KAAA,WACA7B,EAAAK,gBA1HA,CAuKChB","file":"static/js/269.9a482b8a.chunk.js","sourcesContent":["(function (Prism) {\n  var expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n  var params = {\n    'quoted-string': {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      alias: 'operator'\n    },\n    'command-param-id': {\n      pattern: /(\\s)\\w+:/,\n      lookbehind: true,\n      alias: 'property'\n    },\n    'command-param-value': [{\n      pattern: expressionDef,\n      alias: 'selector'\n    }, {\n      pattern: /([\\t ])\\S+/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'operator'\n    }, {\n      pattern: /\\S(?:.*\\S)?/,\n      alias: 'operator'\n    }]\n  };\n  Prism.languages.naniscript = {\n    // ; ...\n    'comment': {\n      pattern: /^([\\t ]*);.*/m,\n      lookbehind: true\n    },\n    // > ...\n    // Define is a control line starting with '>' followed by a word, a space and a text.\n    'define': {\n      pattern: /^>.+/m,\n      alias: 'tag',\n      inside: {\n        'value': {\n          pattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n          lookbehind: true,\n          alias: 'operator'\n        },\n        'key': {\n          pattern: /(^>)\\w+/,\n          lookbehind: true\n        }\n      }\n    },\n    // # ...\n    'label': {\n      pattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n      lookbehind: true,\n      alias: 'regex'\n    },\n    'command': {\n      pattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n      lookbehind: true,\n      alias: 'function',\n      inside: {\n        'command-name': /^@\\w+/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'command-params': {\n          pattern: /[\\s\\S]*\\S[\\s\\S]*/,\n          inside: params\n        }\n      }\n    },\n    // Generic is any line that doesn't start with operators: ;>#@\n    'generic-text': {\n      pattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n      lookbehind: true,\n      alias: 'punctuation',\n      inside: {\n        // \\{ ... \\} ... \\[ ... \\] ... \\\"\n        'escaped-char': /\\\\[{}\\[\\]\"]/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'inline-command': {\n          pattern: /\\[[\\t ]*\\w+[^\\r\\n\\[\\]]*\\]/,\n          greedy: true,\n          alias: 'function',\n          inside: {\n            'command-params': {\n              pattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n              lookbehind: true,\n              inside: params\n            },\n            'command-param-name': {\n              pattern: /^(\\[[\\t ]*)\\w+/,\n              lookbehind: true,\n              alias: 'name'\n            },\n            'start-stop-char': /[\\[\\]]/\n          }\n        }\n      }\n    }\n  };\n  Prism.languages.nani = Prism.languages['naniscript'];\n  /** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n  /**\n   * This hook is used to validate generic-text tokens for balanced brackets.\n   * Mark token as bad-line when contains not balanced brackets: {},[]\n   */\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    /** @type {(Token | string)[]} */\n    var tokens = env.tokens;\n    tokens.forEach(function (token) {\n      if (typeof token !== \"string\" && token.type === 'generic-text') {\n        var content = getTextContent(token);\n\n        if (!isBracketsBalanced(content)) {\n          token.type = 'bad-line';\n          token.content = content;\n        }\n      }\n    });\n  });\n  /**\n   * @param {string} input\n   * @returns {boolean}\n   */\n\n  function isBracketsBalanced(input) {\n    var brackets = \"[]{}\";\n    var stack = [];\n\n    for (var i = 0; i < input.length; i++) {\n      var bracket = input[i];\n      var bracketsIndex = brackets.indexOf(bracket);\n\n      if (bracketsIndex !== -1) {\n        if (bracketsIndex % 2 === 0) {\n          stack.push(bracketsIndex + 1);\n        } else if (stack.pop() !== bracketsIndex) {\n          return false;\n        }\n      }\n    }\n\n    return stack.length === 0;\n  }\n\n  ;\n  /**\n   * @param {string | Token | (string | Token)[]} token\n   * @returns {string}\n   */\n\n  function getTextContent(token) {\n    if (typeof token === 'string') {\n      return token;\n    } else if (Array.isArray(token)) {\n      return token.map(getTextContent).join('');\n    } else {\n      return getTextContent(token.content);\n    }\n  }\n})(Prism);"],"sourceRoot":""}