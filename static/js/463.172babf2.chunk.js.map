{"version":3,"sources":["../node_modules/prismjs/components/prism-zig.js"],"names":["Prism","literal","str","keyword","IDENTIFIER","source","ALIGN","TYPE","replace","languages","zig","comment","pattern","alias","string","lookbehind","greedy","builtin","label","class-name","RegExp","inside","builtin-types","function","number","boolean","operator","punctuation","forEach","obj"],"mappings":"+EAAA,SAAAA,GACA,SAAAC,EAAAC,GACA,kBACA,OAAAA,GAIA,IAAAC,EAAA,sVACAC,EAAA,SAAAD,EAAAE,OAAA,kBACAC,EAAA,oCAAAD,OAGAE,EAAA,sBAFA,0GAAAF,OAAAG,QAAA,WAAAP,EAAAK,IAEA,SADA,2DAAAD,OAAAG,QAAA,QAAAP,EAAAG,IACA,KAkBAJ,EAAAS,UAAAC,IAAA,CACAC,QAAA,EACAC,QAAA,UACAC,MAAA,eACK,WACLC,OAAA,EAEAF,QAAA,oCACAG,YAAA,EACAC,QAAA,GACK,CAELJ,QAAA,iDACAG,YAAA,EACAC,QAAA,GACK,CAELJ,QAAA,wEACAG,YAAA,EACAC,QAAA,IAEAC,QAAA,wBACAC,MAAA,CACAN,QAAA,4EACAG,YAAA,GAEAI,aAAA,CACA,8EAA8E,CAI9EP,QAAAQ,OAAA,0EAA6Ff,OAAAG,QAAA,UAAAP,EAAAM,IAAAC,QAAA,WAAAP,EAAAK,KAC7FS,YAAA,EACAM,OAAA,MAEK,CAELT,QAAAQ,OAAA,uCAA0Df,OAAAG,QAAA,UAAAP,EAAAM,IAAAC,QAAA,WAAAP,EAAAK,KAC1DS,YAAA,EACAM,OAAA,OAGAC,gBAAA,CACAV,QAAA,oKACAC,MAAA,WAEAV,UACAoB,SAAA,uBACAC,OAAA,2GACAC,QAAA,qBACAC,SAAA,6EACAC,YAAA,iBAEA3B,EAAAS,UAAAC,IAAA,cAAAkB,QAAA,SAAAC,GACA,OAAAA,EAAAR,SACAQ,EAAAR,OAAArB,EAAAS,UAAAC,OArFA,CAwFCV","file":"static/js/463.172babf2.chunk.js","sourcesContent":["(function (Prism) {\n  function literal(str) {\n    return function () {\n      return str;\n    };\n  }\n\n  var keyword = /\\b(?:align|allowzero|and|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n  var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n  var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n  var PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n  var SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n  var TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n  /*\n   * A simplified grammar for Zig compile time type literals:\n   *\n   * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n   *\n   * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n   *\n   * PREFIX_TYPE_OP = \"?\"\n   *                | \\b \"promise\" \"->\"\n   *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n   *\n   * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n   *\n   * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n   *\n  */\n\n  Prism.languages.zig = {\n    'comment': [{\n      pattern: /\\/{3}.*/,\n      alias: 'doc-comment'\n    }, /\\/{2}.*/],\n    'string': [{\n      // \"string\" and c\"string\"\n      pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n      lookbehind: true,\n      greedy: true\n    }, {\n      // multiline strings and c-strings\n      pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n      lookbehind: true,\n      greedy: true\n    }, {\n      // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n      pattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n      lookbehind: true,\n      greedy: true\n    }],\n    'builtin': /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n    'label': {\n      pattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n      lookbehind: true\n    },\n    'class-name': [// const Foo = struct {};\n    /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/, {\n      // const x: i32 = 9;\n      // var x: Bar;\n      // fn foo(x: bool, y: f32) void {}\n      pattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n      lookbehind: true,\n      inside: null // see below\n\n    }, {\n      // extern fn foo(x: f64) f64; (optional alignment)\n      pattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n      lookbehind: true,\n      inside: null // see below\n\n    }],\n    'builtin-types': {\n      pattern: /\\b(?:anyerror|bool|c_u?(?:short|int|long|longlong)|c_longdouble|c_void|comptime_(?:float|int)|[iu](?:8|16|32|64|128|size)|f(?:16|32|64|128)|noreturn|type|void)\\b/,\n      alias: 'keyword'\n    },\n    'keyword': keyword,\n    'function': /\\b(?!\\d)\\w+(?=\\s*\\()/,\n    'number': /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+\\.?[a-fA-F\\d]*(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+\\.?\\d*(?:[eE][+-]?\\d+)?)\\b/,\n    'boolean': /\\b(?:false|true)\\b/,\n    'operator': /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n    'punctuation': /[.:,;(){}[\\]]/\n  };\n  Prism.languages.zig['class-name'].forEach(function (obj) {\n    if (obj.inside === null) {\n      obj.inside = Prism.languages.zig;\n    }\n  });\n})(Prism);"],"sourceRoot":""}